<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://allanlrh.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://allanlrh.github.io/blog/" rel="alternate" type="text/html" /><updated>2020-10-18T08:45:26-05:00</updated><id>https://allanlrh.github.io/blog/feed.xml</id><title type="html">Allan’s braindump</title><subtitle>A place to share my thoughts on technology and Data Science wit the world; a slight bias towards Python are to be expected</subtitle><entry><title type="html">Command line tools of a modern age</title><link href="https://allanlrh.github.io/blog/command-line/2020/10/04/Command-line-tools-of-a-modern-age.html" rel="alternate" type="text/html" title="Command line tools of a modern age" /><published>2020-10-04T00:00:00-05:00</published><updated>2020-10-04T00:00:00-05:00</updated><id>https://allanlrh.github.io/blog/command-line/2020/10/04/Command-line-tools-of-a-modern-age</id><content type="html" xml:base="https://allanlrh.github.io/blog/command-line/2020/10/04/Command-line-tools-of-a-modern-age.html">&lt;h1 id=&quot;command-line-tools-of-a-modern-age&quot;&gt;Command line tools of a modern age&lt;/h1&gt;

&lt;p&gt;I have been using command line tools for years, but in the past few I have grown increasingly accustomed to a new “generation” of command line tools.
They differentiate themself by being optimized for ease of use and present information in a human-friendly manner, rather than offering a plethora of options.&lt;/p&gt;

&lt;h2 id=&quot;the-tools&quot;&gt;The tools&lt;/h2&gt;

&lt;p&gt;I’m using &lt;a href=&quot;https://www.zsh.org/&quot;&gt;Zsh&lt;/a&gt; as my shell, and currently also using &lt;a href=&quot;https://github.com/ohmyzsh/ohmyzsh&quot;&gt;Oh-my-Zsh&lt;/a&gt; (though I’m considering going with a more lightweight solution).&lt;/p&gt;

&lt;p&gt;Now let’s have a look at the tools, shall we?&lt;/p&gt;

&lt;h3 id=&quot;ripgrep-rg-implenented-in-rust&quot;&gt;&lt;a href=&quot;https://github.com/BurntSushi/ripgrep#ripgrep-rg&quot;&gt;Ripgrep&lt;/a&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rg&lt;/code&gt;, implenented in Rust)&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Fast &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt;-like, Git-aware code-search with colourized output.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Albeit its name suggest it’s a replacement for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt; (which it is), I’d argue that it’s a replacement for &lt;a href=&quot;https://beyondgrep.com/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ack&lt;/code&gt;&lt;/a&gt;.
It’s a tool intended for performing blazing fast searches of your code, but unlike &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt;, it respects the patterns defined in your &lt;em&gt;.gitignore&lt;/em&gt; file, and it doesn’t search your &lt;em&gt;.git&lt;/em&gt;-directory either.&lt;/p&gt;

&lt;p&gt;Ripgrep also knows about filetypes (which can have multiple file-extensions).
To search for all markdown-files containing the string &lt;em&gt;README&lt;/em&gt;, we could simply run:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;❯ rg -t md README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/command-line-tools-of-a-modern-age-assets/ripgrep-markdown-search-readme.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;But what file extensions are included in the markdown filter?
Let’s check:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;❯ rg --type-list | grep -P &quot;^md&quot;
md: *.markdown, *.md, *.mdown, *.mkdn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It’s also worth noticing that Ripgrep uses regular expressions by default
&lt;img src=&quot;/blog/images/command-line-tools-of-a-modern-age-assets/ripgrep-markdown-regex-search.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It’s a tool I use all the time, and I highly recommend checking it out!
The Github page gives a nice overview of its capabilities.&lt;/p&gt;

&lt;p&gt;Oh, and it works on Windows too!&lt;/p&gt;

&lt;h3 id=&quot;fd-implemented-in-rust&quot;&gt;&lt;a href=&quot;https://github.com/sharkdp/fd#fd&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt;&lt;/a&gt; (implemented in Rust)&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Fast Git-aware file searching with colourized output.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt; is for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find&lt;/code&gt; what Ripgrep is for grep: It searches filenames and respects your &lt;em&gt;.gitignore&lt;/em&gt; patterns.
But unlike the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find&lt;/code&gt;-command, the options are easy to remember… Suppose we want to find all&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;files&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;which is at most two directories below our working directory,&lt;/li&gt;
  &lt;li&gt;and is greater than 4 kB,&lt;/li&gt;
  &lt;li&gt;whose name ends with &lt;em&gt;.py&lt;/em&gt; (notice that it’s expressed as a regex)&lt;/li&gt;
  &lt;li&gt;and count the number of lines in those files by invoking the command &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wc -l&lt;/code&gt; on each file.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/command-line-tools-of-a-modern-age-assets/fd-options-exec-wc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;While the long-form might seem a bit slow, I find the options very easy to memorize, and in terms of speed, that beat looking them up.
But you could of course memorize the short-hand version of the one you use the most.&lt;/p&gt;

&lt;p&gt;If you find yourself googling the command line options for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find&lt;/code&gt;-command, you should give &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt; a chance.
Lastly, have a look at this gif from the README, which beautifully demonstrates &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt;:
&lt;img src=&quot;https://raw.githubusercontent.com/sharkdp/fd/a38da63a345da0c19c8be62072759cd8a5f24df0/doc/screencast.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Oh, and it works on Windows too!&lt;/p&gt;

&lt;h3 id=&quot;exa-implemented-in-rust&quot;&gt;&lt;a href=&quot;https://the.exa.website/https://the.exa.website/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exa&lt;/code&gt;&lt;/a&gt; (implemented in Rust)&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;A Git-aware &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ls&lt;/code&gt; replacement with clever utilization of colour.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Exa aims to replace &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ls&lt;/code&gt;, and have long been my daily driver, using a few aliases for listing files and files including hidden files respectively:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;l='exa --long --git --ignore-glob &quot;._*&quot; --color-scale --header --group-directories-first'
la='exa --all --long --git --ignore-glob &quot;._*&quot; --color-scale --header --group-directories-first'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/command-line-tools-of-a-modern-age-assets/exa-black.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I like how its use of colour enables me to quickly scan the screen to find the information I’m looking for, be it file-permissions or file-size.
Using the tool, I get the feeling that the use of colour is carefully applied to convey the information on the screen to the user the most convenient way possible.&lt;/p&gt;

&lt;p&gt;The capabilities of exa goes a bit beyond that of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ls&lt;/code&gt;, as it can also draw the file-trees:
&lt;img src=&quot;/blog/images/command-line-tools-of-a-modern-age-assets/exa-tree.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;fzf&quot;&gt;&lt;a href=&quot;https://github.com/junegunn/fzf&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fzf&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Fuzzy-filtering of streams of text.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fzf&lt;/code&gt; is a fuzzy-finder for the command line.
Think of it as an interactive version of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt;, where you don’t have to spell the string which you’re searching for 100 % correctly… you can miss some characters here and there, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fzf&lt;/code&gt; will still include your desired result in the filtered list.&lt;/p&gt;

&lt;p&gt;By itself &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fzf&lt;/code&gt; isn’t that useful, but it elevates the interactiveness and user experience a lot of other command line tools.&lt;/p&gt;

&lt;p&gt;Below is an example where I use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fzf&lt;/code&gt; to filter my command history — see the &lt;a href=&quot;https://github.com/junegunn/fzf/wiki&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fzf&lt;/code&gt; Github Wiki&lt;/a&gt; for setup instructions:
&lt;img src=&quot;/blog/images/command-line-tools-of-a-modern-age-assets/fzf-history-search.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tokei-implemented-in-rust&quot;&gt;&lt;a href=&quot;https://github.com/XAMPPRocky/tokei&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tokei&lt;/code&gt;&lt;/a&gt; (implemented in Rust)&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Git-aware statistics for code.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Count number of lines, filetypes comments… useful when you encounter a new codebase, and quickly need to gain an overview of the code.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/command-line-tools-of-a-modern-age-assets/tokei-sort-lines.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;starship-implemented-in-rust&quot;&gt;&lt;a href=&quot;https://starship.rs/&quot;&gt;Starship&lt;/a&gt; (implemented in Rust)&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Shell prompt rich on contextual information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You might have noticed that I have a lot of information in my prompt; it’s provided by the program Starship.
Starship supports Bash, Fish, Zsh and Powershell.&lt;/p&gt;

&lt;p&gt;While you can configure Starship your particular needs, I’ve found the standard settings quite useful and never bothered configuring it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/starship/starship/master/media/demo.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="command-line" /><summary type="html">Command line tools of a modern age</summary></entry></feed>