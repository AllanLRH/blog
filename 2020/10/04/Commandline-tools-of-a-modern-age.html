<h1 id="commandline-tools-of-a-modern-age">Commandline tools of a modern age</h1>

<p>I have been using commandline tools for years, but in the past few I have grown increasingly accustomed to a new “generation” of commandline tools.
They differentiate themself by being optimized for ease of use and present information in a human-friendly manner, rather than offering a plethora of options.</p>

<h2 id="the-tools">The tools</h2>

<p>I’m using <a href="https://www.zsh.org/">Zsh</a> as my shell, and currently also using <a href="https://github.com/ohmyzsh/ohmyzsh">Oh-my-Zsh</a> (though I’m considering going with a more lightweight solution).</p>

<p>Now let’s have a look at the tools, shall we?</p>

<h3 id="ripgrep-rg-implenented-in-rust"><a href="https://github.com/BurntSushi/ripgrep#ripgrep-rg">Ripgrep</a> (<code class="highlighter-rouge">rg</code>, implenented in Rust)</h3>

<p><em>Fast <code class="highlighter-rouge">grep</code>-like, Git-aware code-search with colorized output.</em></p>

<p>Albeit it’s name suggest it’s a replacement for <code class="highlighter-rouge">grep</code> (which it is), I’d argue that it’s a replacement for <a href="https://beyondgrep.com/"><code class="highlighter-rouge">ack</code></a>.
It’s a tool intended for performing blazing fast searches of your code, but unlike <code class="highlighter-rouge">grep</code>, it respects the patterns defined in your <em>.gitignore</em> file, and it doesn’t search your <em>.git</em>-directory either.</p>

<p>Ripgrep also knows about filetypes (which can have multiple file-extensions).
To search for all markdown-files containing the string <em>README</em>, we could simply run:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>❯ rg -t md README
</code></pre></div></div>

<p><img src="./commandline-tools-of-a-modern-age-assets/ripgrep-markdown-search-readme.png" alt="" /></p>

<p>But what file extensions are included in the markdown filter?
Let’s check:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>❯ rg --type-list | grep -P "^md"
md: *.markdown, *.md, *.mdown, *.mkdn
</code></pre></div></div>

<p>It’s also worth noticing that Ripgrep uses regular expressions by default
<img src="./commandline-tools-of-a-modern-age-assets/ripgrep-markdown-regex-search.png" alt="" /></p>

<p>It’s a tool I use all the time, and I highlight recommend checking it out.
The Github page gives a nice overview of it’s capabilities.</p>

<p>Oh, and it works on Windows too!</p>

<h3 id="fd-implemented-in-rust"><a href="https://github.com/sharkdp/fd#fd"><code class="highlighter-rouge">fd</code></a> (implemented in Rust)</h3>

<p><em>Fast Git-aware file searching with colorized output.</em></p>

<p><code class="highlighter-rouge">fd</code> is for <code class="highlighter-rouge">find</code> what Ripgrep is for grep: It searches filenames and respects your <em>.gitignore</em> patterns.
But unlike the <code class="highlighter-rouge">find</code>-command, the options are easy to remember… Suppose we want to find all</p>
<ul>
  <li><em>files</em></li>
  <li>which is at most two directories below our working directory,</li>
  <li>and is greater than 4 kB,</li>
  <li>whose name ends with <em>.py</em> (notice that it’s expressed as a regex)</li>
  <li>and count the number of lines in those files by invoking the command <code class="highlighter-rouge">wc -l</code> on each file.</li>
</ul>

<p><img src="./commandline-tools-of-a-modern-age-assets/fd-options-exec-wc.png" alt="" /></p>

<p>While the long form might seem a bit slow, I find the options very easy to memorize, and in terms of speed, that beat looking them up.
But you could of course memorize the short-hand version of the one you use the most.</p>

<p>If you find yourself googling the commandline options for the <code class="highlighter-rouge">find</code>-command, you should give <code class="highlighter-rouge">fd</code> a chance.
Lastly, have a look at this gif from the README, which beautifully demonstrates <code class="highlighter-rouge">fd</code>:
<img src="https://raw.githubusercontent.com/sharkdp/fd/a38da63a345da0c19c8be62072759cd8a5f24df0/doc/screencast.svg" alt="" /></p>

<p>Oh, and it works on Windows too!</p>

<h3 id="exa-implemented-in-rust"><a href="https://the.exa.website/https://the.exa.website/"><code class="highlighter-rouge">exa</code></a> (implemented in Rust)</h3>

<p><em>A Git-aware <code class="highlighter-rouge">ls</code> replacement with clever utilization of color.</em></p>

<p>Exa aims to replace <code class="highlighter-rouge">ls</code>, and have long been my daily driver, using a few aliases for listing files and files including hidden files respectively:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l='exa --long --git --ignore-glob "._*" --color-scale --header --group-directories-first'
la='exa --all --long --git --ignore-glob "._*" --color-scale --header --group-directories-first'
</code></pre></div></div>

<p><img src="./commandline-tools-of-a-modern-age-assets/exa-black.png" alt="" /></p>

<p>I like how it’s use of color enables me to quickly scan the screen to find the information I’m looking for, be it file-permissions or file-size.
Using the tool, I get the feeling that the use of color is a carefully applied in order to convey the information on the screen to the user the most convenient way possible.</p>

<p>The capabilities of exa goes a bit beyond that of <code class="highlighter-rouge">ls</code>, as it can also draw the file-trees:
<img src="./commandline-tools-of-a-modern-age-assets/exa-tree.png" alt="" /></p>

<h3 id="fzf"><a href="https://github.com/junegunn/fzf"><code class="highlighter-rouge">fzf</code></a></h3>

<p><em>Fuzzy-filtering of streams of text.</em></p>

<p><code class="highlighter-rouge">fzf</code> is a fuzzy-finder for the commandline.
Think of it as an interactive version of <code class="highlighter-rouge">grep</code>, where you don’t have to spell the string which you’re searching for 100 % correctly… you can miss some characters here and there, and <code class="highlighter-rouge">fzf</code> will still include your desired result in the filtered list.</p>

<p>By itself <code class="highlighter-rouge">fzf</code> isn’t that useful, but it elevates the interactiveness and user experience a lot of other commandline tools.</p>

<p>Below is an example where I use <code class="highlighter-rouge">fzf</code> to filter my command history — see the <a href="https://github.com/junegunn/fzf/wiki"><code class="highlighter-rouge">fzf</code> Github Wiki</a> for setup instructions:
<img src="./commandline-tools-of-a-modern-age-assets/fzf-history-search.gif" alt="" /></p>

<h3 id="tokei-implemented-in-rust"><a href="https://github.com/XAMPPRocky/tokei"><code class="highlighter-rouge">tokei</code></a> (implemented in Rust)</h3>

<p><em>Git-aware statistics for code.</em></p>

<p>Count number of lines, filetypes comments… useful when you encounter a new codebase, and quickly need to gain an overview of the code.</p>

<p><img src="./commandline-tools-of-a-modern-age-assets/tokei-sort-lines.png" alt="" /></p>

<h3 id="starship-implemented-in-rust"><a href="https://starship.rs/">Starship</a> (implemented in Rust)</h3>

<p><em>Shell prompt rich on information.</em></p>

<p>You might have noticed that I have a lot of information in my prompt; it’s provided by the program Starship.
Starship supports Bash, Fish, Zsh and Powershell.</p>

<p>While you can configure Starship your particular needs, I’ve found the standard settings quite useful, and never bothered configuring it.</p>

<p><img src="https://raw.githubusercontent.com/starship/starship/master/media/demo.gif" alt="" /></p>
